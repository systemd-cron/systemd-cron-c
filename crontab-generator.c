/*-*- Mode: C; c-basic-offset: 8; indent-tabs-mode: nil -*-*/

/***
  This file is part of systemd.

  Copyright 2013 Shawn Landden

  systemd is free software; you can redistribute it and/or modify it
  under the terms of the GNU Lesser General Public License as published by
  the Free Software Foundation; either version 2.1 of the License, or
  (at your option) any later version.

  systemd is distributed in the hope that it will be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public License
  along with systemd; If not, see <http://www.gnu.org/licenses/>.
***/

#include <errno.h>
#include <stdio.h>
#include <unistd.h>
#include <dirent.h>
#include <stdbool.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

#include "log.h"
#include "util.h"
#include "fileio.h"

#ifndef CRONTAB_PATH
#define CRONTAB_PATH "/etc/crontab"
#endif

#ifndef CRONTAB_DIR_PATH
#define CRONTAB_DIR_PATH "/etc/cron.d/"
#endif

#ifndef SYSTEMD_GENERATOR_PATH
#define SYSTEMD_GENERATOR_PATH "/run/systemd/generator"
#endif

const char *daysofweek[] = {"Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"};
const char *iscrontabline = "0123456789*";
const char *isdow = "0123456";

static const char *arg_dest = "/tmp";

static int parse_dow(char *dow, char *dows){
        char c[2] = {"\0\0"};

        assert(dow);

        dows[0] = '\0';

        for(unsigned s = 0;s < strlen(dow);s++) {
                c[0] = dow[s];
                if (strchr(isdow, c[0]))
                        strncpy(dows + strlen(dows), daysofweek[atoi(&c[0])], 128 - strlen(dows));
                else {
                        int l = strlen(dows);
                        if (l < 128) {
                                dows[l] = c[0];
                                dows[l+1] = '\0';
                        }
                }
        }

        return 0;
}

/*                             system means has a user field */
static int parse_crontab_entry(bool system, char *line, const char *context, char *usertab) {
        int r = 0;
        int commandloc = 0;
        char m[8], h[8], dom[8], mon[8], dow[8], user[64], command[1024];
        _cleanup_free_ char *timer = NULL, *timerfn = NULL, *service = NULL, *servicefn = NULL;
        char dows[128];
        char *p;

        assert(line);
        assert(context);

        if (system)
                r = sscanf(line, "%s %s %s %s %s %s %n", m, h, dom, mon, dow, user, &commandloc);
        else
                r = sscanf(line, "%s %s %s %s %s %n", m, h, dom, mon, dow, &commandloc);
        if (r == EOF)
                return -errno;

        p = strchr(&line[commandloc], '\n');
        p[0] = '\0';
        strcpy(&command[0], &line[commandloc]);
        if (user == NULL)
                strcpy(usertab, user);

        r = parse_dow(dow, &dows[0]);
        if (r < 0)
                return r;

        asprintf(&timerfn, SYSTEMD_GENERATOR_PATH "/cron-%s.timer", context);
        asprintf(&timer,"# Automatically generated by systemd-cron-generator\n"
                "# Was: %s\n"
                "[Unit]\n"
                "Description=[Cron] %s\n"
                "PartOf=cron.target\n"
                "RefuseManualStart=true\n"
                "RefuseManualStop=true\n"
                "\n"
                "[Timer]\n"
                "OnCalendar=%s *-%s-%s %s:%s\n"
                "Unit=cron-%s.service", line, context, dows, mon, dom, h, m, context);

        asprintf(&servicefn, SYSTEMD_GENERATOR_PATH "/cron-%s.service", context);
        asprintf(&service,"# Automatically generated by systemd-cron-generator\n"
                "# Was: %s\n"
                "[Unit]\n"
                "Description=[Cron] %s\n"
                "RefuseManualStart=true\n"
                "RefuseManualStop=true\n"
                "\n"
                "[Service]\n"
                "Type=oneshot\n"
                "User=%s"
                "ExecStart=/bin/sh -c \"%s\"\n", line, context, user, command);
        if (!timer || !timerfn || !service || !servicefn)
                return -log_oom();

        r = write_string_file(timerfn, timer);
        if (r < 0)
                return r;

        r = write_string_file(servicefn, service);
        if (r < 0)
                return r;

        return r;
}

static int parse_crontab(const char *filename) {
        int r = 0;
        _cleanup_fclose_ FILE *fp = NULL;
        char l[1024];
        _cleanup_free_ char *context = NULL;

        assert(filename);

        fp = fopen(filename, "r");
        if (!fp) {
                log_error("fopen() failed: %m");
                return -errno;
        }

        for (int ln = 0;l != NULL; ln++) {
                char *f;
                f = fgets(l, sizeof(l), fp);
                if (!f)
                        break;
                if (strchr(iscrontabline,l[0])) {
                        asprintf(&context, "%s-l%d", strrchr(filename, '/') + 1, ln);
                        r = parse_crontab_entry(true, (char *)&l, context, NULL);
                        if (r < 0)
                                return r;
                }
        }

        return r;
}


int main(int argc, char *argv[]) {
        int r = 0;
	DIR *dirp;
	struct dirent *dent;

        if (argc > 1 && argc != 4) {
                log_error("This program takes three or no arguments.");
                return EXIT_FAILURE;
        }

        if (argc > 1)
                arg_dest = argv[1];

        log_set_target(LOG_TARGET_SAFE);
        log_parse_environment();
        log_open();

        umask(0022);

        r = parse_crontab(CRONTAB_PATH);
	if (r < 0) {
                log_error("%m");
		goto exit;
        }

	dirp = opendir(CRONTAB_DIR_PATH);
	if (dirp == NULL) {
		log_error("opendir() failed: %m");
		r = -errno;
		goto exit;
	}

	while (1) {
                dent = readdir(dirp);
                if (!dent)
                        break;
		r = parse_crontab(strappend(CRONTAB_DIR_PATH, dent->d_name));
		if (r < 0) {
                        log_error("%m");
                        goto exit;
                }
	}

exit:
        return (r < 0) ? EXIT_FAILURE : EXIT_SUCCESS;
}
